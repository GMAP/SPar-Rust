From Dalvan's thesis.

Notation:
	T_id    = ToStream token
	S_id    = Stage token
	B_id    = Block containing one or more statements
	I_list  = Input
	O_list  = Output
	R_n     = Replicate
	[[...]] = ToStream OR Stage with or without a list of attributes
	{}      = scope of the sentence

Functions:
	farm(E(B_id), W(B_id), C(B_id)):
		E = emitter (task scheduler)
		C = collector (gather implementation)
		W = worker(do the actual work, possibly replicated by R_n)
		NOTE: E and C are optional

	pipe(...):
		accepts 2 or more B_id or farm(). Each represents a stage of the pipeline

Rules:
	0 - if the last block is a stage, with R_n > 1 and O_list, we need another
	stage to gather the results (to preserve ordering). To do that, we introduce
	a special block, that we'll call #.
	1 - if the block is not a stage, or is a stage without R_n, it
	can be the argument of pipe(), E, or C.
	2 - if the block is a stage with R_n, it can only be an argument of W. If
	Rule 1 is satisfied, the predecessor block becomes E and the successor
	becomes C
	3 - T can only become a farm() if:
		There are at most two stages in the sentence; AND
		Only the first stage contains an R_n
	4 - T can only become a pipe() if:
		There more than two stages in the sentence; OR
		The fist stage does not have R_n
	5 - farm() is a stage inside a pipe() when ruler 3 failed and the stage
	contains a R_n


